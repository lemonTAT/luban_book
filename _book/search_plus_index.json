{"./":{"url":"./","title":"Introduction","keywords":"","body":"鲁班应用搭建平台 Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-25 09:32:48 "},"introduction/app.html":{"url":"introduction/app.html","title":"应用的构成","keywords":"","body":"应用的构成 从本质上讲，所有Web应用都是一种运行在网页浏览器中的软件，这些软件的图形用户界面（Graphical User Interface，简称GUI）即为前端。 Web应用是一种GUI软件 1、应用由页面构成 整个Web应用由页面组成 2、页面由组件组成 3、一个组件一个目录，资源就近维护 4、组件可组合，组件的JS可依赖其他JS模块，CSS可依赖其他CSS单元 3大框架定义了组件的开发和管理规范，应用往往由多功能、多页面、多状态、多系统构成。逻辑编排，数据拆包解包，最终通过JS(胶水)将这些逻辑，组件粘合在一起形成我们的页面。这带来了一下一些问题： 1、页面的组件无法做到可插拔，只能通过代码修改实现 2、逻辑编排、UI、数据拆解包通过JS粘合在一起，业务的变更和改动必须通过代码修改实现 3、当业务发生变更，我们往往又需要设计代码修改和发布 参考资料 前端工程——基础篇 致我们终将组件化的 Web Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-22 11:00:48 "},"introduction/bigrender.html":{"url":"introduction/bigrender.html","title":"BigRender","keywords":"","body":"Bigrender介绍 参考资料 淘宝详情页的 BigRender 优化与存放大块 HTML 内容的最佳方式 Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-22 11:02:29 "},"luban/about.html":{"url":"luban/about.html","title":"鲁班","keywords":"","body":"鲁班 鲁班基于多年技术积累沉淀，传承精雕细琢的工匠精神，推出GUI搭建平台（鲁班）。 方案概述 鲁班提供的Web GUI开发的基础套件。主要提供鲁班市场、应用页面、可视化设计器、调用Dubbo和执行Bash的能力，另外还包括相应的一些基础服务。鲁班底层依赖React和Antd、Antd-Mobile，可以运行在主流浏览器。 鲁班方案 Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-22 14:32:35 "},"luban/timeline.html":{"url":"luban/timeline.html","title":"鲁班时序图","keywords":"","body":"鲁班时序图 Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-25 15:07:54 "},"luban/bigrender.html":{"url":"luban/bigrender.html","title":"鲁班BigRender","keywords":"","body":"Bigrender介绍 React 挂载节点 挂载节点的数据包 BundleJS 18260f50-f496-11e9-9e67-bd27e8391cdd是BundleJS的挂载点，通过React工程开发完成的组件编译成一个JS束，在JS运行的时候动态挂载对应的区块。 ReactDOM.render(, document.getElementById(blockId)); Bigrender区块 Bigrender区块用于存放组件束信息，UI Schema、Data Schema、取数逻辑、页面逻辑编排等信息。 { \"component_id\":44, \"sourceUrl\":\"\", \"blockId\":\"18260f50-f496-11e9-9e67-bd27e8391cdd\", \"schema\":\"{\"formConfig\":[{\"type\":\"Input\",\"formName\":\"eventTypeDisplay\",\"displayName\":\"事件类型:\",\"placeholder\":\"请输入事件类型\",\"initialValue\":\"\",\"style\":{\"width\":\"150px\"}},{\"type\":\"Input\",\"formName\":\"riskManager\",\"displayName\":\"策略经理:\",\"placeholder\":\"请输入策略经理\",\"initialValue\":\"\",\"style\":{\"width\":\"150px\"}}]}\", \"blockData\":\"\", \"eventIds\":[ ], \"create_time\":1568736173000, \"id\":44, \"moduleName\":\"Form\", \"moduleDesc\":\"表单组件\", \"version\":\"1.0.0\", \"npmName\":\"@tongdun/td_form\", \"css\":\"/static/css/form/form.css\", \"js\":\"/static/js/form/form.js\" } Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-22 15:09:54 "},"luban/rgl.html":{"url":"luban/rgl.html","title":"鲁班可视化布局","keywords":"","body":"可视设计器介绍 基于react-grid-layout实现可拓展，可调整的layout布局。区块具备UUID唯一编号，UUID全局唯一。 Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-22 15:36:25 "},"luban/loader.html":{"url":"luban/loader.html","title":"加载器","keywords":"","body":"Loader LubanLoader.css(url, blockId) url(加载地址): string blockId(区块ID):string 加载CSS束 LubanLoader.loadScript(url, blockId, async, next) 网页性能优化之异步加载js文件 url(加载地址): string blockId(区块ID):string async(JS 延时加载):defer|async next(区块ID):function 加载CSS束 LubanLoader.getCurrentBigRenderData() LubanLoader.getBigRenderData(blockId) blockId(区块ID):string LubanLoader.removeBundle(blockId) blockId(区块ID):string ;(function(root, factory) { if (typeof exports === 'object') { // CommonJS module.exports = exports = factory(); } else if (typeof define === 'function' && define.amd) { // AMD define([], factory); } else { // Global (browser) root.LubanLoader = factory(); } }(this, function() { var LubanLoader = LubanLoader || (function(window, document) { var LubanLoader = {}; LubanLoader.version = '1.0.0'; var head = document.getElementsByTagName('head')[0]; var body = document.getElementsByTagName('body')[0]; // 异步加载JS var loadScript = LubanLoader.loadScript = function(url, blockId, async, next) { var script = document.createElement('script'); script.charset = 'UTF-8'; script.async = async; if (blockId) { script.dataset.jsBlockId = blockId; } script.onerror = function() { next && next(true); }; var loaded = false; script.onload = script.onreadystatechange = function() { if (!loaded && (!script.readyState || 'loaded' === script.readyState || 'complete' === script.readyState)) { loaded = true; setTimeout(function() { next && next(false); }, 0); } }; script.src = url; body.appendChild(script); }; // 异步加载CSS var loadCss = LubanLoader.loadCss = function(url, blockId) { var style = document.createElement('link'); style.href = url; if (blockId) { style.dataset.cssBlockId = blockId; } style.rel = 'stylesheet'; style.type = 'text/css'; head.appendChild(style); }; /** * 获取当前执行JS的blockId */ var getCurrentBlockId = LubanLoader.getCurrentBlockId = function() { /** * 当前正在被执行的脚本 * https://caniuse.com/#search=currentScript */ var currentScript = document.currentScript; return (currentScript && currentScript.dataset.jsBlockId) || 'container'; }; /** * 获取blockId对应BigRenderData * @type {function()} */ var getCurrentBigRenderData = LubanLoader.getCurrentBigRenderData = function() { /** * 当前正在被执行的脚本 * https://caniuse.com/#search=currentScript */ var currentUUID = LubanLoader.getCurrentBlockId(); var bigRenderDataEle = document.querySelectorAll(`[data-block-textarea=\"${currentUUID}\"]`); var bigRenderDataStr = (bigRenderDataEle.length > 0 && bigRenderDataEle[0].innerText) || ''; var bigRenderDataObj = {}; if (bigRenderDataStr) { bigRenderDataObj = JSON.parse(bigRenderDataStr); } return bigRenderDataObj; }; /** * 获取block bigrenderData */ var getBigRenderData = LubanLoader.getBigRenderData = function(blockId) { var bigRenderDataEle = document.querySelectorAll(`[data-block-textarea=\"${blockId}\"]`); var bigRenderDataStr = (bigRenderDataEle.length > 0 && bigRenderDataEle[0].innerText) || ''; var bigRenderDataObj = {}; if (bigRenderDataStr) { bigRenderDataObj = JSON.parse(bigRenderDataStr); } return bigRenderDataObj; }; /** * 移除block bundle 资源 */ var removeBundleEle = LubanLoader.removeBundleEle = function(blockId) { var cssBundleEle = document.querySelectorAll(`[data-css-block-id=\"${blockId}\"]`); var jsBundleEle = document.querySelectorAll(`[data-js-block-id=\"${blockId}\"]`); cssBundleEle && cssBundleEle[0] && cssBundleEle[0].remove(); jsBundleEle && jsBundleEle[0] && jsBundleEle[0].remove(); }; /** * eventId收敛 */ var getLubanEventId = LubanLoader.getLubanEventId = function(moduleName, blockId, eventType) { var eventStr = 'Luban'; if (moduleName) { eventStr = eventStr + `.${moduleName}`; } if (blockId) { eventStr = eventStr + `.${blockId}`; } if (eventType) { eventStr = eventStr + `.${eventType}`; } return eventStr; }; var throwLubanError = LubanLoader.throwLubanError = function(msg) { throw new Error(`${msg}`); }; return LubanLoader; }(window, document)); return LubanLoader; })); Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-25 09:44:36 "},"luban/event.html":{"url":"luban/event.html","title":"业务编排","keywords":"","body":"发布订阅模式 pubsub-js API API 功能 subscribe 订阅一个主题，并绑定事件处理函数 subscribeOnce 订阅一个主题，执行一次后，立即注销订阅 publish 异步发布消息 publishSync 同步发布消息 clearSubscriptions 清空特定订阅主题 clearAllSubscriptions 清空所有订阅主题 unsubscribe 注销订阅特定主题 A.B.C.D A位:固定'Luban' B位:功能/模块/组件 C位:UUID D位:事件类型 分层寻址 Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-22 16:07:47 "},"browser/render.html":{"url":"browser/render.html","title":"渲染原理","keywords":"","body":"浏览器内核的理解？ 主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎则：解析和执行javascript来实现网页的动态效果。 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 一个页面的呈现，粗略的说会经过以下这些步骤： 1、DOM 树的构建（Parse HTML） 2、构建 CSSOM 树（Recaculate Style） 3、合并 DOM 树与 CSSOM 树为 Render 树 4、布局（Layout） 5、绘制（Paint） 6、复合图层化（Composite） 其中布局（Layout）环节主要负责各元素尺寸、位置的计算，绘制（Paint）环节则是绘制页面像素信息，合成（Composite）环节是多个复合层的合成，最终合成的页面被用户看到。 当用户在浏览网页时进行交互或通过 js 脚本改变页面结构时，以上的部分操作有可能重复运行，此过程称为 Repaint 或 Reflow。 Repaint(重绘) 当元素改变的时候，将不会影响元素在页面当中的位置（比如 background-color, border-color, visibility），浏览器仅仅会应用新的样式重绘此元素，此过程称为 Repaint。 Reflow(重排) 当元素改变的时候，将会影响文档内容或结构，或元素位置，此过程称为 Reflow。（ HTML 使用的是 flow based layout ，也就是流式布局，所以，如果某元件的几何尺寸发生了变化，需要重新布局，也就叫 Reflow。） Reflow 的成本比 Repaint 的成本高得多的多。一个结点的 Reflow 很有可能导致子结点，甚至父点以及同级结点的 Reflow 。在一些高性能的电脑上也许还没什么，但是如果 Reflow 发生在手机上，那么这个过程是延慢加载和耗电的。 以下行为将有可能产生 Reflow 增加、删除、或改变 DOM 节点 增加、删除 ‘class’ 属性值 元素尺寸改变 文本内容改变 浏览器窗口改变大小或拖动 动画效果进行计算和改变 CSS 属性值 伪类激活（:hover） 延伸阅读： 浏览器内核、JS 引擎、页面呈现原理及其优化 chrome浏览器页面渲染工作原理浅析 Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2020-02-24 10:22:47 "},"browser/history.html":{"url":"browser/history.html","title":"路由History","keywords":"","body":"Histories 常用的 history 有三种形式 browserHistory hashHistory createMemoryHistory browserHistory Browser history 是使用 React Router 的应用推荐的 history。 hashHistory Hash history 使用 URL 中的 hash（#）部分去创建形如 example.com/#/some/path 的路由。 createMemoryHistory Memory history 不会在地址栏被操作或读取。这就解释了我们是如何实现服务器渲染的。同时它也非常适合测试和其他的渲染环境（像 React Native ）。 Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2020-02-25 16:19:45 "},"browser/ssr.html":{"url":"browser/ssr.html","title":"服务端渲染SSR","keywords":"","body":"服务端渲染 一套代码既可以在服务端运行又可以在客户端运行，就是服务端直出和客户端渲染的组合。 为什么同构？ 性能:通过Node直出, 将传统的三次串行http请求简化成一次http请求，降低首屏渲染时间 SEO:服务端渲染对搜索引擎的爬取有着天然的优势 统一:前后端一套技术栈 后端渲染、客户端渲染(CSR)、同构应用(SSR) 后端渲染:服务器直接生成HTML文档并返回给浏览器，但页面交互能力有限。适用于任何后端语言：PHP、Java、Python、GO等。 客户端渲染:页面初始加载的HTML文档中无内容，需要下载执行JS文件，由浏览器动态生成页面，并通过JS进行页面交互事件与状态管理。 同构:isomorphic/universal，基于react、vue框架，客户端渲染和服务器端渲染的结合，在服务器端执行一次，用于实现服务器端渲染（首屏直出），在客户端再执行一次，用于接管页面交互，核心解决SEO和首屏渲染慢的问题。 参考资料 后端渲染、客户端渲染(CSR)、同构应用(SSR) Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2020-02-25 16:36:40 "},"knowledge/pubsub.html":{"url":"knowledge/pubsub.html","title":"PubSub JS源码解读","keywords":"","body":"设计模式 观察者设计模式 观察者模式在软件设计中是一个对象，维护一个依赖列表，当任何状态发生改变自动通知它们。 发布-订阅设计模式 在观察者模式中的Subject就像一个发布者（Publisher），观察者（Observer）完全和订阅者（Subscriber）关联。subject通知观察者就像一个发布者通知他的订阅者。这也就是很多书和文章使用“发布-订阅”概念来解释观察者设计模式。但是这里还有另外一个流行的模式叫做发布-订阅设计模式。 在发布-订阅模式，消息的发送方，叫做发布者（publishers），消息不会直接发送给特定的接收者，叫做订阅者。 区别： 在观察者模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。 在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。 观察者模式大多数时候是同步的，比如当事件触发，Subject就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）。 观察者 模式需要在单个应用程序地址空间中实现，而发布-订阅更像交叉应用模式。 Pubsub源码解读 在浏览器环境下使用，通过script标签来引入这个类库 通过NPM安装使用 兼容 ES6(ES2015) 的模块系统、CommonJS 和 AMD 模块规范 (function (root, factory){ 'use strict'; var PubSub = {}; //浏览器全局变量(root 即 window) root.PubSub = PubSub; var define = root.define; factory(PubSub); // AMD support if (typeof define === 'function' && define.amd){ define(function() { return PubSub; }); // CommonJS and Node.js module support } else if (typeof exports === 'object'){ if (module !== undefined && module.exports) { exports = module.exports = PubSub; // Node.js specific `module.exports` } exports.PubSub = PubSub; // CommonJS module 1.1.1 spec module.exports = exports = PubSub; // CommonJS } }(( typeof window === 'object' && window ) || this, function (PubSub){ 'use strict'; var messages = {}, lastUid = -1; //hasOwnProperty,判断一个对象是否具有给出名称的属性和对象 function hasKeys(obj){ var key; for (key in obj){ if ( obj.hasOwnProperty(key) ){ return true; } } return false; } /** * Returns a function that throws the passed exception, for use as argument for setTimeout * @alias throwException * @function * @param { Object } ex An Error object */ function throwException( ex ){ return function reThrowException(){ throw ex; }; } function callSubscriberWithDelayedExceptions( subscriber, message, data ){ try { subscriber( message, data ); } catch( ex ){ setTimeout( throwException( ex ), 0); } } function callSubscriberWithImmediateExceptions( subscriber, message, data ){ subscriber( message, data ); } function deliverMessage( originalMessage, matchedMessage, data, immediateExceptions ){ var subscribers = messages[matchedMessage], callSubscriber = immediateExceptions ? callSubscriberWithImmediateExceptions : callSubscriberWithDelayedExceptions, s; if ( !messages.hasOwnProperty( matchedMessage ) ) { return; } for (s in subscribers){ if ( subscribers.hasOwnProperty(s)){ callSubscriber( subscribers[s], originalMessage, data ); } } } function createDeliveryFunction( message, data, immediateExceptions ){ return function deliverNamespaced(){ var topic = String( message ), position = topic.lastIndexOf( '.' ); // deliver the message as it is now deliverMessage(message, message, data, immediateExceptions); // trim the hierarchy and deliver message to each level while( position !== -1 ){ topic = topic.substr( 0, position ); position = topic.lastIndexOf('.'); deliverMessage( message, topic, data, immediateExceptions ); } }; } function messageHasSubscribers( message ){ var topic = String( message ), found = Boolean(messages.hasOwnProperty( topic ) && hasKeys(messages[topic])), position = topic.lastIndexOf( '.' ); while ( !found && position !== -1 ){ topic = topic.substr( 0, position ); position = topic.lastIndexOf( '.' ); found = Boolean(messages.hasOwnProperty( topic ) && hasKeys(messages[topic])); } return found; } function publish( message, data, sync, immediateExceptions ){ message = (typeof message === 'symbol') ? message.toString() : message; var deliver = createDeliveryFunction( message, data, immediateExceptions ), hasSubscribers = messageHasSubscribers( message ); if ( !hasSubscribers ){ return false; } if ( sync === true ){ deliver(); } else { setTimeout( deliver, 0 ); } return true; } /** * Publishes the message, passing the data to it's subscribers * @function * @alias publish * @param { String } message The message to publish * @param {} data The data to pass to subscribers * @return { Boolean } */ PubSub.publish = function( message, data ){ return publish( message, data, false, PubSub.immediateExceptions ); }; /** * Publishes the message synchronously, passing the data to it's subscribers * @function * @alias publishSync * @param { String } message The message to publish * @param {} data The data to pass to subscribers * @return { Boolean } */ PubSub.publishSync = function( message, data ){ return publish( message, data, true, PubSub.immediateExceptions ); }; /** * Subscribes the passed function to the passed message. Every returned token is unique and should be stored if you need to unsubscribe * @function * @alias subscribe * @param { String } message The message to subscribe to * @param { Function } func The function to call when a new message is published * @return { String } */ PubSub.subscribe = function( message, func ){ if ( typeof func !== 'function'){ return false; } message = (typeof message === 'symbol') ? message.toString() : message; // message is not registered yet if ( !messages.hasOwnProperty( message ) ){ messages[message] = {}; } // forcing token as String, to allow for future expansions without breaking usage // and allow for easy use as key names for the 'messages' object var token = 'uid_' + String(++lastUid); messages[message][token] = func; // return token for unsubscribing return token; }; /** * Subscribes the passed function to the passed message once * @function * @alias subscribeOnce * @param { String } message The message to subscribe to * @param { Function } func The function to call when a new message is published * @return { PubSub } */ PubSub.subscribeOnce = function( message, func ){ var token = PubSub.subscribe( message, function(){ // before func apply, unsubscribe message PubSub.unsubscribe( token ); func.apply( this, arguments ); }); return PubSub; }; /** * Clears all subscriptions * @function * @public * @alias clearAllSubscriptions */ PubSub.clearAllSubscriptions = function clearAllSubscriptions(){ messages = {}; }; /** * Clear subscriptions by the topic * @function * @public * @alias clearAllSubscriptions */ PubSub.clearSubscriptions = function clearSubscriptions(topic){ var m; for (m in messages){ if (messages.hasOwnProperty(m) && m.indexOf(topic) === 0){ delete messages[m]; } } }; /** * Removes subscriptions * * - When passed a token, removes a specific subscription. * * - When passed a function, removes all subscriptions for that function * * - When passed a topic, removes all subscriptions for that topic (hierarchy) * @function * @public * @alias subscribeOnce * @param { String | Function } value A token, function or topic to unsubscribe from * @example // Unsubscribing with a token * var token = PubSub.subscribe('mytopic', myFunc); * PubSub.unsubscribe(token); * @example // Unsubscribing with a function * PubSub.unsubscribe(myFunc); * @example // Unsubscribing from a topic * PubSub.unsubscribe('mytopic'); */ PubSub.unsubscribe = function(value){ var descendantTopicExists = function(topic) { var m; for ( m in messages ){ if ( messages.hasOwnProperty(m) && m.indexOf(topic) === 0 ){ // a descendant of the topic exists: return true; } } return false; }, isTopic = typeof value === 'string' && ( messages.hasOwnProperty(value) || descendantTopicExists(value) ), isToken = !isTopic && typeof value === 'string', isFunction = typeof value === 'function', result = false, m, message, t; if (isTopic){ PubSub.clearSubscriptions(value); return; } for ( m in messages ){ if ( messages.hasOwnProperty( m ) ){ message = messages[m]; if ( isToken && message[value] ){ delete message[value]; result = value; // tokens are unique, so we can just stop here break; } if (isFunction) { for ( t in message ){ if (message.hasOwnProperty(t) && message[t] === value){ delete message[t]; result = true; } } } } } return result; }; })); Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2020-02-25 16:01:33 "},"knowledge/domdiff.html":{"url":"knowledge/domdiff.html","title":"React Virtual Dom Diff","keywords":"","body":"Dom Diff 本质上是 DOM树比较，React变成了Virtual DOM。 传统 diff 算法的复杂度为 O(n^3)，显然这是无法满足性能要求的。React 通过制定大胆的策略，将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题。 diff 策略 Web UI中DOM节点跨层级的移动特别少，可以忽略不计 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构 对于同一层级的一组(具有相同父元素的)子节点，它们可以通过唯一id进行区分(即key) tree diff 基于策略一，React 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。 既然 DOM 节点跨层级的移动操作少到可以忽略不计，针对这一现象，React 通过 updateDepth 对 Virtual DOM 树进行层级控制，只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。 注意：在开发组件时，保持稳定的 DOM 结构会有助于性能的提升。例如，可以通过 CSS 隐藏或显示节点，而不是真的移除或添加 DOM 节点。 component diff React 是基于组件构建应用的，对于组件间的比较所采取的策略也是简洁高效。 如果是同一类型的组件，按照原策略继续比较 virtual DOM tree。 如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。 对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切的知道这点那可以节省大量的 diff 运算时间，因此 React 允许用户通过 shouldComponentUpdate() 来判断该组件是否需要进行 diff。 注意：PureComponent基于shallowEqual进行浅比较，实际开发中组件保持简单结构数据，避免复杂对象嵌套，组件上少用内联函数。 element diff React diff 提供了三种节点操作，分别为：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。 React 提出优化策略：允许开发者对同一层级的同组子节点，添加唯一 key 进行区分，虽然只是小小的改动，性能上却发生了翻天覆地的变化！ 总结 React 通过制定大胆的 diff 策略，将 O(n3) 复杂度的问题转换成 O(n) 复杂度的问题； React 通过分层求异的策略，对 tree diff 进行算法优化； React 通过相同类生成相似树形结构，不同类生成不同树形结构的策略，对 component diff 进行算法优化； React 通过设置唯一 key的策略，对 element diff 进行算法优化； 在开发组件时，保持稳定的 DOM 结构会有助于性能的提升； 在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。 参考资料 React 源码剖析系列 － 不可思议的 react diff 使用recompose给React开发加点料 Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-28 16:24:55 "},"knowledge/redux.html":{"url":"knowledge/redux.html","title":"Redux数据流","keywords":"","body":"Redux数据流 所谓 Redux，就是将动作(action) 变换成 state 转换函数(reducer)，然后放到一个统一的地方(store)来 setState 而已。 单向性 单向数据流其实并不是redux的特性，而是react本身的思想。这个下面有例子会说明。 唯一性 指的是应用的数据都会集中存储在一个地方，这个数据Store就像一个池子，任何组件都可以通过固定的管道来传输或者获取这个池子里面的数据 时间旅行 这个“时间旅行”另外的意思是可预测（predictable），即容易理解的代码。在redux里，任何一个数据都有状态。一个用户操作或者程序需要去修改数据，都必须触发Action，这时在redux看来，其实数据是从一个状态，变化成另一个状态。这么一来，数据就变得可预测，可以知道数据的前置状态(prev state)和后置状态(next state)分别是什么，如果在这里加上单元测试，也是极其容易的一件事情。 Redux权衡方案 用简单的对象和数组来描述应用状态 用简单的对象来描述应用中的状态变化 用纯函数来描述应用中逻辑变化 这意味着你必须遵循一定的规则才可以让你的程序走通。对应的三个文件分别是Action，Reducer，Store，同时也是Redux最重要的3个概念。 Action(电报员) Actions 是把数据从应用传到 store 的有效载荷。它是 store 数据的唯一来源。用法是通过 store.dispatch() 把 action 传到 store。 Dispatch(接线员) 分发 Reducer(秘书长) 协助处理数组 Store(总司令) 真正的状态存储地方 View触发dispatch 进入reducer，修改store中的state 将新的state和props传入handleChange中，生成更符合页面的props 传给原始根节点重新render Redux的优点： Redux把流程规范了，统一渲染根节点虽然对代码管理上规范了一些,只要有需要显示数据的组件，当相关数据更新时都会自动进行更新。 减少手动编码量，提高编码效率。 Redux 会更加注重数据的单一流向性，所有的 Component Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-28 18:22:12 "},"knowledge/stream.html":{"url":"knowledge/stream.html","title":"nodejs中流(stream)的理解","keywords":"","body":"nodejs中流(stream)的理解 什么是Stream（流） 流（stream）在 Node.js 中是处理流数据的抽象接口（abstract interface）。 stream 模块提供了基础的 API 。使用这些 API 可以很容易地来构建实现流接口的对象。 防止处理二进制文件，比如音频、视频文件，避免内存“爆仓”。 Node.js 中有四种基本类型的流：可读流，可写流，双向流以及变换流。 Readable - 可读流是对一个可以读取数据的源的抽象。fs.createReadStream 方法是一个可读流的例子。 Writable - 可写流是对一个可以写入数据的目标的抽象。fs.createWriteStream 方法是一个可写流的例子。 Duplex - 双向流既是可读的，又是可写的。TCP socket 就属于这种。 Transform - 变换流是一种特殊的双向流，它会基于写入的数据生成可供读取的数据。例如使用 zlib.createGzip 来压缩数据。你可以把一个变换流想象成一个函数，这个函数的输入部分对应可写流，输出部分对应可读流。你也可能听说过变换流有时被称为 “thought streams”。 所有的流都是 EventEmitter 的实例。它们发出可用于读取或写入数据的事件。然而，我们可以利用 pipe 方法以一种更简单的方式使用流中的数据。 管道流(pipe) // 创建可读流 const reader = fs.createReadStream(file.path); const fileId = uuidv4(); const filePath = `${path.join(process.cwd(), 'upload')}/${fileId}.${file.name.split('.')[1]}`; // 创建可写流 const upStream = fs.createWriteStream(filePath); // 可读流通过管道写入可写流 reader.pipe(upStream); /** * 等到上传完毕在解锁 */ upStream.on('finish', () => { ...do something }); 参考资料 Node.js 流: 你需要知道的一切 Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-28 18:22:12 "},"knowledge/child_process.html":{"url":"knowledge/child_process.html","title":"node子进程spawn,exec","keywords":"","body":"node子进程spawn,exec child_process介绍 Nodejs是单线程单进程的，但是有了child_process模块，可以在程序中直接创建子进程，并使用主进程和子进程之间实现通信。 child_process.spawn spawn应该是创建子进程的一个基本的方法。该方法接受三个参数： command，表示要执行命令的字符串。 args，表示执行命令的命令行参数，如果不提供默认值是一个空数组。 options，可选配置。 其中options可以配置的属性有： 1、cwd，配置该命令执行的目录。 2、stdio，配置子进程跟父进程直接的输入输出方式。 3、env，配额子进程中的环境变量。 4、detached，配置子进程是否独立的。默认情况下父进程是需要等待子进程结束才能结束，当这个配置为true时，父进程不需要等待子进程结束，子进程会在后台继续执行。（子进程使用了父进程的io则这个配置始终都是默认情况。） 5、uid，配置执行子进程的用户id。 6、gid，配置执行子进程的用户组id。 child_process.exec exec是spawn的简化版本，三个参数： command，要执行的命令的字符串。 options，可选的配置。 callback，一个回调函数。当子进程结束的时候会被调用。 options跟spawn类似，有cwd、env，其他的配置如下： 1、encoding，输出流的编码，默认是utf8。 2、timeout，子进程执行的超时时间，默认是0,表示没有超时时间。 3、maxBuffer，输出流的缓冲区大小，默认是200×1024，注意，当输出的内容超过缓冲区的大小子进程会被杀掉。 4、killSignal，子进程被杀的信号，默认是SIGTERM。 其中回调函数有三个输入参数：error、stdout和error，分别对应错误输出、正常输出和执行的错误对象。由于这个回调函数封装了两个输出的内容和错误对象，有大部分的场景都可以不去使用返回的ChildProcess对象，直接使用这个回调函数即可。 参考资料 Node中spawn和exec的区别 Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-28 17:46:03 "},"knowledge/list.html":{"url":"knowledge/list.html","title":"知识点清单","keywords":"","body":" 闭包 this指针 原型链 理解JavaScript中的call,apply和bind方法 构造函数与new命令 理解Javascript原型链 JavaScript 中的 this 十大经典排序算法 JavaScript 标准参考教程 ECMAScript 6 入门 JavaScript深入系列15篇正式完结！ 前端小册 阿里前端p7架构图谱 前端面试宝典 | 100+面试题200+书籍推荐 Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-27 12:31:10 "},"knowledge/closure.html":{"url":"knowledge/closure.html","title":"闭包","keywords":"","body":"JavaScript 作用域和闭包 作用域 JavaScript 作用域指定了哪些变量你能够访问。有两种作用域 —— 全局作用域和局部作用域 全局作用域 如果一个变量在函数外面或者大括号（{}）外申明，那么就是定义了一个全局作用域的变量。 局部作用域 在你代码特定范围之内申明的变量可以称为处于局部作用域中，这些变量也被称为局部作用域。 在 JavaScript 中，有两种局部作用于：函数作用域和块作用域。 函数作用域 当你在函数中申明一个变量，你就只能够在这个函数范围内使用它。在范围之外你不能使用。 块作用域 当你在一个大括号中（{}）使用 const 或者 let 申明变量，那么这个变量只能够在这个大括号范围内使用。 函数提升和作用域 当你申明一个函数时，它总是会提升到作用域顶部。 函数不能相互调用各自的作用域 当你定义函数时，他们不能够相互使用各自的作用域，虽然它们可以互相调用。 嵌套作用域 当一个函数在另一个函数内定义，内部的函数能够访问外部函数的变量。 闭包 当你在一个函数内部创建一个函数时，你就创建了一个闭包。内部函数就是闭包。这个闭包总是会 return 出来，所以你能够稍后使用外部函数中的变量。 因为闭包允许变量来自外部的函数，他们通常被用来： 解决副作用 创建私有变量 我的理解是，闭包就是能够读取其他函数内部变量的函数。 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成\"定义在一个函数内部的函数\"。 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包的用途 它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 使用闭包的注意点 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 参考资料 学习Javascript闭包（Closure） 你不可不知道的 JavaScript 作用域和闭包 Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-27 10:41:25 "},"knowledge/this.html":{"url":"knowledge/this.html","title":"JavaScript中的this","keywords":"","body":"JavaScript 中的 this 全局 在全局作用域中它的 this 执行当前的全局对象（浏览器端是 Window，node 中是 global）。 函数中执行 纯粹的函数调用 函数被直接调用的时候，属于全局调用，这时候它的 this 指向 全局对象; 严格模式: 'use strict'; 严格模式的情况下执行纯粹的函数调用，那么这里的的 this 并不会指向全局，而是 undefined，这样的做法是为了消除 js 中一些不严谨的行为。 对象的方法调用 this 指向当前的这个对象； 构造函数使用 当作构造函数调用时，this 指向了这个构造函数调用时候实例化出来的对象。 箭头函数 ES6箭头函数中的 this 只和定义它时候的作用域的 this 有关，而与在哪里以及如何调用它无关，同时它的 this 指向是不可改变。 call, apply, bind 改变函数中的 this 指向 call() 语法：fun.call(thisArg, arg1, arg2, ...) call()调用一个函数，第一个参数为指定的this值，其他参数是分别的提供的参数，用逗号分隔 通俗来讲，call()把父函数在子函数中运行了一遍，但是this是子函数的实例 apply() apply()和call()使用上是一致的，唯一的区别call()方法接受若干个参数的列表，而apply()方法接受的是一个包含多个参数的数组。 请注意，传递给call()和apply()的第一个参数是相同的(即绑定this值的对象)。 bind() bind()也是在函数上调用方法，不同于call()和apply()，它回返回一个新的函数，该函数将this设置为我们赋给它的值。 参考资料 JavaScript 中的 this call(), apply(), bind() 应用与区别 Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-27 11:09:04 "},"knowledge/prototype.html":{"url":"knowledge/prototype.html","title":"原型(prototype)和原型链(proto)","keywords":"","body":"原型(prototype)和原型链(proto) 道生一，一生二，二生三，三生万物。万物负阴而抱阳，冲气以为和。 -- 老子 《道德经》 原型是函数对象的属性，不是所有对象的属性，对象经过构造函数new出来，那么这个new出来的对象的构造函数有一个属性叫原型。 道：空值 理解Javascript（以下简称“JS”）之道，需要先理解undefined与null的区别。 在JS中，undefined是全局对象的一个属性，它的初始值就是原始数据类型undefined，并且无法被配置，也无法被改变。undefined从字面意思上理解为“未定义”，即表示一个变量没有定义其值。 而null是一个JS字面量，表示空值，即没有对象。与undefined相比，null被认为是“期望一个对象，但是不引用任何对象的值”，而undefined是纯粹的“没有值”。 null是对象原型链的终点，其值既有（是一个对象）又无（不引用任何对象），代表着对象本源的一种混沌、虚无的状态,正与老子《道德经》中的“道”，有着同等的意义。 道生一：原型 JS中的所有事物都是对象：字符串、数字、数组、日期，等等。在JS中，对象是拥有属性和方法的数据。 为了描述这些事物，JS便有了“原型（prototype）”的概念。 显式原型（explicit prototype property） 每一个函数在创建之后都会拥有一个名为prototype的属性，这个属性指向函数的原型对象。用来实现基于原型的继承与属性的共享。 隐式原型 （implicit prototype link） JS中任意对象都有一个内置属性proto（部分浏览器为[[prototype]]），指向创建这个对象的函数（即构造函数）constructor的prototype。用来构成原型链，同样用于实现基于原型的继承。 对象的原型Object.prototype用来描述最基本的对象。万物皆对象，所有的对象均具有隐式原型proto，对象的原型也不例外。因为它生于虚无，所以它的proto属性指向null，即原型链的最顶端。而该原型，就是JS中万物之始。 一生二：对象与函数 拥有了描述事物的能力，却没有创造事物的能力，显然是不完整的，因此需要一个Object的生成器来进行对象的生成。 JS将生成器以构造函数constructor来表示，构造函数是一个指针，指向了一个函数。 函数（function） 函数是指一段在一起的、可以做某一件事的程序。构造函数是一种创建对象时使用的特殊函数。 对象的构造函数function Object同时也是一个对象，因此需要一个能够描述该对象的原型，该原型便是Function.prototype，函数的原型用来描述所有的函数。对象的构造函数的proto指向该原型。 函数的原型本身也是对象，因此其proto指向了对象的原型。同样，该对象也需要一个对应的生成器，即其构造函数function Function。 函数与对象相互依存，分别定义了事物的描述方法和事物的生成方法，在生成JS万物的过程中缺一不可。 二生三：类 类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础。类是一种用户定义类型，也称类类型。每个类包含数据说明和一组操作数据或传递消息的函数。类的实例称为对象。 在ECMAScript 2015 中引入的JS类（classes）之前，要在JS中实现类便是采用原型继承的方式。 当把一个函数作为构造函数，使用new关键字来创建对象时，便可以把该函数看作是一个类，创建出来的对象则是该类的实例，其隐式原型proto指向的是该构造函数的原型。 在访问该对象的属性或方法时，JS会先搜索该对象中是否定义了该属性或方法，若没有定义，则会回溯到其proto指向的原型对象去搜索，若仍然未搜索到，则会继续回溯该原型的原型，直到搜索到原型链的终点null; 这种特性可以理解为：构造函数生成的实例，继承于该构造函数的原型。 得益于这种特性，我们可以使用定义构造函数的方式来定义类。 以上定义了Person类，该构造函数是由Function构造而来，所以其隐式原型指向函数的原型，而为了描述该事物，同时生成了该类的原型Person.prototype，该原型又是由Object构造而来，所以其隐式原型指向了对象的原型。 三生万物：实例 通过定义不同的类，可以对万物进行描述。而每个类对应的构造函数，即为万物的生成器。通过new构造函数，可以得到类对应的实例，该实例可以理解为实实在在的事物，而不同于前述函数和对象这种抽象的定义了。 定义属性 通过属性，我们更加详细地去描述它。this是JS中的一个关键字，代表了函数运行时生成的一个内部对象，该对象通常指的是调用该函数的那个对象。该对象只能在函数中使用。如果该函数是以构造函数的方式被调用，则this指的是通过该构造函数实例化的实例对象。 定义方法 在属性定义后，还应该拥有行为。行为可以被抽象成函数，我们称之为“方法”。 我们通过将函数作为构造函数参数的传递进去的方式，给实例添加方法，在调用这些方法时，这些方法内部的this指向的是调用其的对象。 公共属性&方法 通过上述方式定义方法，必须在实例化一个对象的时候来定义方法的实现，这样显然不是很可取。大多数情况下，我们需要定义的方法应该是该类的所有实例都共用的方法。 通过给该构造函数的原型添加方法，这些方法定义在原型中，所有实例对象都是原型的继承，同样会将原型的属性和方法继承下来。 总结 万物皆实例，实例又都是由类来进行描述，而实例的属性即为对象，实例的方法即为函数，由此可见，万物都是由对象和函数相依相生来进行定义的。而对象又定义了函数，函数又构造了对象，这种关系又由“原型”的方式进行链接，组成了JS的多态世界。 JS之道，万物自成一体，理解了这个道理，掌握JS的原型便不成问题。 个人理解：你一直在用，只是你不知道。本质上是为了实现OOP。 是什么 显式原型 函数在创建之后都会拥有一个名为prototype的属性，这个属性指向函数的原型对象。 隐式原型 JavaScript中任意对象都有一个内置属性[[prototype]]，在ES5之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过proto来访问。ES5中有了对于这个内置属性标准的Get方法Object.getPrototypeOf()。 Object.prototype 这个对象是个例外，它的proto值为null。 隐式原型指向创建这个对象的函数(constructor)的prototype 作用是什么 显式原型的作用：用来实现基于原型的继承与属性的共享。 隐式原型的作用：构成原型链，同样用于实现基于原型的继承。举个例子，当我们访问obj这个对象中的x属性时，如果在obj中找不到，那么就会沿着proto依次查找。 参考资料 道生万物,理解Javascript原型链 进阶必读：深入理解 JavaScript 原型 说说原型（prototype）、原型链和原型继承 深入理解javascript中的原型 Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-29 15:27:47 "},"knowledge/es6.html":{"url":"knowledge/es6.html","title":"ES6全部特性","keywords":"","body":"ES6全部特性 概括ES6全部特性 Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-27 11:53:17 "},"knowledge/algorithm.html":{"url":"knowledge/algorithm.html","title":"算法","keywords":"","body":"算法(algorithm) 算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量。 五大特征: 有限性(Finiteness):一个算法必须保证执行有限步之后结束。 确切性(Definiteness):一个算法的每一步骤必须有确切的定义。 输入(Input):一个算法有零个或多个输入，以刻画运算对象的初始情况，所谓零个输入是指算法本身给定了初始条件。 输出(Output):一个算法有一个或多个输出。没有输出的算法毫无意义。 可行性(Effectiveness):一个算法的任何计算步骤都是可以被分解为基本可执行的操作，每个操作都能够在有限时间内完成。 十大算法 冒泡排序 冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 对于提升性能来说并没有什么太大作用。 算法步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 动画演示 Code function bubbleSort(arr) { var len = arr.length; for (var i = 0; i arr[j+1]) { // 相邻元素两两对比 var temp = arr[j+1]; // 元素交换 arr[j+1] = arr[j]; arr[j] = temp; } } } return arr; } 选择排序 选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。 算法步骤 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 动画演示 Code function selectionSort(arr) { var len = arr.length; var minIndex, temp; for (var i = 0; i 插入排序 插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。 算法步骤 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） 动画演示 Code function insertionSort(arr) { var len = arr.length; var preIndex, current; for (var i = 1; i = 0 && arr[preIndex] > current) { arr[preIndex+1] = arr[preIndex]; preIndex--; } arr[preIndex+1] = current; } return arr; } 参考资料 十大经典排序算法总结(JavaScript描述) Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-28 15:17:12 "},"knowledge/ast.html":{"url":"knowledge/ast.html","title":"AST 抽象语法树","keywords":"","body":"AST 抽象语法树 什么是抽象语法树 在计算机科学中，抽象语法树（abstract syntax tree 或者缩写为 AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。树上的每个节点都表示源代码中的一种结构。 抽象语法树其实就是将一类标签转化成通用标识符，从而结构出的一个类似于树形结构的语法树。 参考资料 AST 抽象语法树 前端码农之蜕变 — AST（抽象语法树） 前端对AST（抽象语法树）的应用越来越多，应该看什么书籍才能补充这方面的知识点？ Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-27 17:02:50 "},"leetcode/twoSum.html":{"url":"leetcode/twoSum.html","title":"1、两数之和","keywords":"","body":"两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] code: 暴力搜索,传送门 /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { var index=[]; for(var i = nums.length-1; i > 0; i--) { // 从后往前找,N位 for(var j = i - 1; j >= 0; j--) { // 从后往前找, debugger if(nums[j] + nums[i] == target) { index.push(j); index.push(i); return index; } } } }; Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-29 10:28:46 "},"leetcode/addTwoNumbers.html":{"url":"leetcode/addTwoNumbers.html","title":"2、两数相加","keywords":"","body":"两数相加 code: 暴力搜索,传送门 /** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */ var addTwoNumbers = function(l1, l2) { var c1 = l1, c2 = l2, l3, c3, carry = 0; while (c1 || c2 || carry) { var v1 = 0, v2 = 0; // 这么做是为了防止整数中当前位上没有数字 if (c1) { v1 = c1.val; c1 = c1.next; } if (c2) { v2 = c2.val; c2 = c2.next; } var sum = v1 + v2 + carry; carry = Math.floor(sum / 10); if (!c3) { l3 = new ListNode(sum % 10); c3 = l3; } else { c3.next = new ListNode(sum % 10); c3 = c3.next; } } return l3; }; Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-28 14:19:22 "},"leetcode/merge.html":{"url":"leetcode/merge.html","title":"88、合并两个有序数组","keywords":"","body":"合并两个有序数组 code: 暴力搜索,传送门 /** * @param {number[]} nums1 * @param {number} m * @param {number[]} nums2 * @param {number} n * @return {void} Do not return anything, modify nums1 in-place instead. */ var merge = function(nums1, m, nums2, n) { //取得nums1的前m项 nums1.splice(m); //取得nums2的前n项 nums2.splice(n); //将nums2合并到nums1中 nums1.push(...nums2); // 升序排序, 當我們想要由小往大 nums1.sort((a,b) => a - b); // 降序排序, 當我們想要由大至小 // nums1.sort((a,b)=>b-a); }; JavaScript Array 对象 Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-28 14:39:53 "},"subject/400.html":{"url":"subject/400.html","title":"前端知识题","keywords":"","body":"前端知识题 400 道前端面试题！阿里、头条、网易等 19 家大厂面经全公开！ 今日头条前端面试题与解析 Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2020-02-25 09:31:21 "},"subject/answer.html":{"url":"subject/answer.html","title":"答案","keywords":"","body":"知识点 使用过的Koa2中间件 Koa-body原理 一个功能齐全的请求体解析器。支持multipart，urlencoded和json请求体。 { multipart: true, // 支持文件上传 formidable: { maxFileSize: 200 * 1024 * 1024, // 设置上传文件大小最大限制，默认200M }, formLimit: '200mb', jsonLimit: '5mb', textLimit: '5mb', } Get参数获取 ctx.params Post参数获取 ctx.request.body 对Async、Await的理解，内部原理 async---声明一个异步函数：自动将常规函数转换成promise，返回值也是一个promise对象，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数，内部可以使用await； await--暂停异步的功能执行：放在promise调用之前，await强制其他代码等待，直到promise完成并返回结果，只能与promise一起使用，不适用于回调，只能在async函数内部使用。 JavaScript对于异步操作有了终极解决方案。 async 函数是 Generator 函数的语法糖。使用关键字async来表示，在函数内部使用await来表示异步。 Async函数的改进在于下面四点： 内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样 更好的语义。async 和 await 相较于 * 和 yield 更加语义化 更广的适用性。co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise对象。而 async 函数的 await 命令后面则可以是 Promise 或者 原始类型的值（Number，string，boolean，但这时等同于同步操作） 返回值是 Promise。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用 async 函数完美的解决了上面两种方式的问题。流程清晰，直观、语义明显。操作异步流程就如同操作同步流程。同时 async 函数自带执行器，执行的时候无需手动加载。 介绍下Promise，内部实现 Promise是为了解决Javascript回调嵌套过多而产生的。因为支持链式调用，而且书写更加方便，被广大开发者喜爱并纳入了ES2015规范中，目前主流浏览器都支持Promise。 promise上面的方法： Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。相当于与Promise.all() Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。相当于或Promise.race() 有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。Promise.resolve() Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。Promise.reject() 捕捉错误，Promise.prototype.catch() finally 的回调总是会被执行，Promise.prototype.finally() 链式操作，Promise.prototype.then() 对象的状态不受外界影响，Promise存在三个互斥状态：pending、fulfilled、rejected。 Promise构造函数接收一个函数作为参数，这个传入的函数有两个参数，分别是两个函数 resolve和reject作用是，resolve将Promise的状态由未成功变为成功，将异步操作的结果作为参数传递过去；相似的是reject则将状态由未失败转变为失败 对跨域的了解 浏览器的同源策略会导致跨域，这里同源策略又分为以下两种 DOM同源策略：禁止对不同源页面DOM进行操作。这里主要场景是iframe跨域的情况，不同域名的iframe是限制互相访问的。 XmlHttpRequest同源策略：禁止使用XHR对象向不同源的服务器地址发起HTTP请求。只要协议、域名、端口有任何一个不同，都被当作是不同的域，之间的请求就是跨域操作。 跨域的解决方式 CORS CORS常用的配置项有以下几个： Access-Control-Allow-Origin（必含） – 允许的域名，只能填 *（通配符）或者单域名。 Access-Control-Allow-Methods（必含） – 这允许跨域请求的 http 方法（常见有 POST、GET、OPTIONS）。 Access-Control-Allow-Headers（当预请求中包含 Access-Control-Request-Headers 时必须包含） – 这是对预请求当中 Access-Control-Request-Headers 的回复，和上面一样是以逗号分隔的列表，可以返回所有支持的头部。 Access-Control-Allow-Credentials（可选） – 表示是否允许发送Cookie，只有一个可选值：true（必为小写）。如果不包含cookies，请略去该项，而不是填写false。这一项与 XmlHttpRequest 对象当中的 withCredentials 属性应保持一致，即 withCredentials 为true时该项也为true；withCredentials 为false时，省略该项不写。反之则导致请求失败。 Access-Control-Max-Age（可选） – 以秒为单位的缓存时间。在有效时间内，浏览器无须为同一请求再次发起预检请求。 JSONP 基本原理就是通过动态创建script标签,然后利用src属性进行跨域。 服务器代理 浏览器有跨域限制，但是服务器不存在跨域问题，所以可以由服务器请求所要域的资源再返回给客户端。服务器代理是万能的。 postMessage window.postMessage 是一个 HTML5 的 api，允许两个窗口之间进行跨域发送消息。 TCP3次握手 3次握手，4次断开？ 三次握手是怎么握的？ TCP是基于链接的，所以在传输数据前需要先建立链接，TCP在传输上是双工传输，不区分Client端与Server端，为了便于理解，我们把主动发起链接请求的一端称作Client端，把被动建立链接的一端称作Server端。 第一次握手 建立链接前需要Server端先监听端口，因此Server端建立链接前的初始状态就是LISTEN状态 Client端发送SYN同步包，Server端收到同步报，发送完成后Client端的链接状态变成SYN_SENT 第二次握手 Server端收到SYN同步包，同意建立链接，向Client端回复一个ACK。由于TCP是双工传输，Server端也会同时向Client端发送一个SYN，申请Server向Client方向建立链接。发送完ACK和SYN后，Server端的链接状态就变成了SYN_RCVD。 第三次握手 Client收到Server的ACK后，Client端的链接状态就变成了ESTABLISHED状态，同时，Client向Server端发送ACK，回复Server端的SYN请求。 Server端收到Client端的ack后，Server端的链接状态也就变成了的ESTABLISHED状态，此时建连完成，双方随时可以进行数据传输。 四次挥手是怎么挥的？ TCP链接的关闭，通信双方都可以先发起，这里我们以Client端先发起为例。 从图中看出，通信中Client端和Server端两端的链接都是ESTABLISHED状态，然后Client先主动发起了关闭链接请求，Client向Server发送了一个FIN包，表示Client端已经没有数据要发送了，然后Client进入了FIN_WAIT_1状态。 Server端收到FIN后，返回ACK，然后进入CLOSE_WAIT状态。此时Server属于半关闭状态，因为此时Client向Server方向已经不会发送数据了，可是Server向Client端可能还有数据要发送。 当Server端数据发送完毕后，Server端会向Client端发送fin，表示Server端也没有数据要发送了，此时Server进入LAST_ACK状态，就等待Client的应答就可以关闭链接了。 Client端收到Server端的FIN后，回复ACK，然后进入TIME_WAIT状态。TIME_WAIT状态下需要等待2倍的最大报文段生存时间，来保证链接的可靠关闭。之后才会进入CLOSED关闭状态。而Server端收到ACK后直接就进入CLOSED状态。 TCP属于哪一层 第四层传输层 OSI中的层 功能 TCP/IP协议族 应用层 文件传输，电子邮件，文件服务，虚拟终端 TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 表示层 数据格式化，代码转换，数据加密 没有协议 会话层 解除或建立与别的接点的联系 没有协议 传输层 提供端对端的接口 TCP，UDP 网络层 为数据包选择路由 IP，ICMP，RIP，OSPF，BGP，IGMP 数据链路层 传输有地址的帧以及错误检测功能 SLIP，CSLIP，PPP，ARP，RARP，MTU 物理层 以二进制数据形式在物理媒体上传输数据 ISO2110，IEEE802。IEEE802.2 Bind、Call、Apply的区别 介绍下原型链 Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2020-02-26 11:41:57 "},"thinking/captcha.html":{"url":"thinking/captcha.html","title":"AI时代验证码的攻与防","keywords":"","body":"AI时代验证码的攻与防 AI时代验证码的攻与防 Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2020-02-21 10:24:10 "},"thinking/visualization.html":{"url":"thinking/visualization.html","title":"Low/No Code Platform","keywords":"","body":" Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-26 18:28:23 "},"thinking/5gaiot.html":{"url":"thinking/5gaiot.html","title":"5G+AI+IoT 超级互联网时代的思考","keywords":"","body":"鲁班应用搭建平台，\"5G+AI+IOT\" 超级互联网时代一站式解决方案 引言：4G改变生活，5G改变社会。随着中国三大国企电信运营商10月31日星期四宣布正式启动5G商用通信服务，标志着中国5G真正进入全民商用时代。5G+AI+IoT组成的超级互联网时代真正成为大众生活的一部分。回顾整个移动通信发展史，2G时代发短信是最时髦的通信方式，3G时代微信兴起，4G时代手机把衣食住行都“管起来”，那么5G将催生哪些“杀手级”应用？将对互联网产业产生哪些深远影响？ 5G是什么？ 5G是指第五代移动通信技术，具有高速率、低时延、高密度等特点，能支持更高效的信息传输、更快速的信号响应以及海量的终端接入。5G还有一个重要目标是通过新技术手段降低数据成本，这有助数据流量消费不断增加。 Mate 30 Pro 5G上市，作为首批用户我第一时间使用SPEEDTEST实测4G，5G，Wifi下各种网络表现。 低延时 5G 在网络延时和抖动上表现接近家庭500M的带宽的环境，我的5G速度不是全速，全速应该还会更快，一次测试耗流量500M。 低延时为各类传感器、机器人、自动驾驶车辆、虚拟现实等智能设备服务的网络。它将重新定义信息技术相关行业，从零售，交通运输、远程医疗、基础设施、工业制造等方面为社会发展和人类生活带来颠覆性变革，它产生的影响将不亚于电力和汽车。 高速率 5G将催生“瘦终端”。5G的超宽带使云端和本地已经没有差异了，许多应用可以放到云端，这将使终端更加简洁，“变瘦”的终端也会更便宜，使消费者节省了成本。 高密度 3G到4G的过渡主要体现在手机上。但对5G来说，手机和平板电脑只是很小一部分应用，更多的是高可靠、低时延、海量物联等场景，比如车联网、物联网、智慧城市、智能制造等，这些应用的普及会加速驱动技术的升级换代。 AI 人工智能（Artificial Intelligence），英文缩写为AI。它是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。 IOT 超级互联网时代，算力芯片和网络通讯技术的升级换代，5G又会给传统的开发带来新的挑战。树莓派（Raspberry Pi）基金会，2019年6月24日正式发布了Raspberry Pi 4 Model B 基于A72架构、4G LDDR4内存、支持千兆网络、双频802.11ac 无线网络、蓝牙5.0千兆网口。因此可以做物联网设备，也能进行一定量的运算，完全已经达到了今天入门级PC的水平。 “物联网”一词最早由 Kevin Ashton 在1999年提出。当时 Kevin 在宝洁公司从事供应链优化工作，他使用了一种新技术 RFID（射频识别），以此建立一个连接物体的无线网络。虽然现代的物联网主要是基于其他技术，Kevin 提出的物联网概念却依然得到广泛地采用，不断深入人心。 物联网将物理世界抽象到数字世界 (基于传感器的感知能力) 通过数据世界我们将重新认识物理世界 (基于新型网络协议的联网能力) 物理世界的数字化将变革人类的生产实践活动 (基于云数据和大计算的综合处理能力) GUI软件 从本质上讲，所有Web应用都是一种运行在网页浏览器中的软件，这些软件的图形用户界面（Graphical User Interface，简称GUI）即为前端。 如此复杂的Web应用，动辄几十上百人共同开发维护，其前端界面通常也颇具规模，工程量不亚于一般的传统GUI软件： 超级互联网时代的开发思考 端渲染回到云端渲染 5G的高速率让服务端渲染(SSR)重新焕发生机，把渲染放到后端，不仅是同构更关注端到端的服务交互，渲染优化等。 低延时、高速率、高密度，前端网络环境变好 1、在3g和4g时代，针对网络层进行优化，我们会将数据尽可能的放在靠近用户一侧。5g这个原则不变，但是我们会加入云端渲染，客户端仅仅是一个轻量级的客户端。设备可能只需要一个显示屏即可。 2、HTTP2的多路复用，Combo合并请求，种子文件将长缓存一次拉取1-2M的资源文件将变成可能。 3、基于Electron前端可以在用户侧驻留一个端，同时这个端里面集成一个Chrome浏览器，这样可以实现混合部署。既可以获取端的能力，又可以实现远程更新 4、云端存储，离线浏览，实时同步。基于IndexDB将远程的数据在联网的时候实时的克隆到本地，优先使用云端数据。 海量设备入网 大量的IOT设备入网，物理世界抽象到数字世界，将带来大量的中台建设需求。传统的Code开发模式将日益无法支撑爆发式的增持需求。 (泛IOT架构) (mqtt_broker) (arduinos) (WeMos D1 mini NodeMCU) (HuaWei 5G CEP PRO) 算法 硬件能力的提升让我们可以在边缘设备上部署小型运算节点，将运算结果实时的回传云端。基于服务端，直接在Node层调用AI模型实现业务应用。 Node将在5G加持下获取更多的能力，基于边缘设备我们可以部署一个小型节点。这个节点上我们可以适时采集用户图像数据，并利用云端的模型适时检测得到结果，结果适时回传云端。 鲁班应用搭建平台 服务端渲染：基于Next.js 数据互联互通：在HTTP通信层面基于http-proxy-middleware的LubanProxy代理实现跨域和Cookie请求携带。Java语言RPC基于Dubbo2.js，其他语言RPC基于Google GPRC 模型能力调用：在AI层面基于opencv4nodejs实现了对模型的直接调用，基于tesseract实现ORC的能力 看看你长的最像那个名人 交流联系 参考资料 开发板界的「瑞士军刀」—— 树莓派 4 轻体验 前端工程——基础篇 ESP8266 & Public Broker MQTT mosca.io & Node-RED MIDC 2019 小米开发者大会 Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-21 13:32:14 "},"demo/methods.html":{"url":"demo/methods.html","title":"API","keywords":"","body":"定义方法 打印 展示 JavaScript 和 Java 如何输出信息 这里演示 JavaScript 如何输出信息到控制台 console.log('Hello World'); 这里演示 Java 如何输出信息到控制台 System.out.println(\"Hello World\"); 这里是 JavaScript 和 Java 共同的信息 定义变量 这里演示 JavaScript 和 Java 如何定义变量 这里演示 JavaScript 如何定义变量： var i = 0; var j = \"a\"; var k = new function() { } 这里演示 Java 如何定义变量 int i = 0; String j = \"a\"; Object o = new Object(); Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-08 13:39:10 "},"demo/alert.html":{"url":"demo/alert.html","title":"Alert","keywords":"","body":"Info styling [info] For info Use this for infomation messages. Warning styling [warning] For warning Use this for warning messages. Danger styling [danger] For danger Use this for danger messages. Success styling [success] For info Use this for success messages. Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-08 13:39:10 "},"demo/demo.html":{"url":"demo/demo.html","title":"Demo","keywords":"","body":"一级别标题 二级标题 三级标题 区块引用 嵌套引用 /* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress * @license MIT */ ;(function(root, factory) { if (typeof define === 'function' && define.amd) { define(factory); } else if (typeof exports === 'object') { module.exports = factory(); } else { root.NProgress = factory(); } })(this, function() { var NProgress = {}; NProgress.version = '0.2.0'; var Settings = NProgress.settings = { minimum: 0.08, easing: 'ease', positionUsing: '', speed: 200, trickle: true, trickleRate: 0.02, trickleSpeed: 800, showSpinner: true, barSelector: '[role=\"bar\"]', spinnerSelector: '[role=\"spinner\"]', parent: 'body', template: '' }; /** * Updates configuration. * * NProgress.configure({ * minimum: 0.1 * }); */ NProgress.configure = function(options) { var key, value; for (key in options) { value = options[key]; if (value !== undefined && options.hasOwnProperty(key)) Settings[key] = value; } return this; }; /** * Last number. */ NProgress.status = null; /** * Sets the progress bar status, where `n` is a number from `0.0` to `1.0`. * * NProgress.set(0.4); * NProgress.set(1.0); */ NProgress.set = function(n) { var started = NProgress.isStarted(); n = clamp(n, Settings.minimum, 1); NProgress.status = (n === 1 ? null : n); var progress = NProgress.render(!started), bar = progress.querySelector(Settings.barSelector), speed = Settings.speed, ease = Settings.easing; progress.offsetWidth; /* Repaint */ queue(function(next) { // Set positionUsing if it hasn't already been set if (Settings.positionUsing === '') Settings.positionUsing = NProgress.getPositioningCSS(); // Add transition css(bar, barPositionCSS(n, speed, ease)); if (n === 1) { // Fade out css(progress, { transition: 'none', opacity: 1 }); progress.offsetWidth; /* Repaint */ setTimeout(function() { css(progress, { transition: 'all ' + speed + 'ms linear', opacity: 0 }); setTimeout(function() { NProgress.remove(); next(); }, speed); }, speed); } else { setTimeout(next, speed); } }); return this; }; NProgress.isStarted = function() { return typeof NProgress.status === 'number'; }; /** * Shows the progress bar. * This is the same as setting the status to 0%, except that it doesn't go backwards. * * NProgress.start(); * */ NProgress.start = function() { if (!NProgress.status) NProgress.set(0); var work = function() { setTimeout(function() { if (!NProgress.status) return; NProgress.trickle(); work(); }, Settings.trickleSpeed); }; if (Settings.trickle) work(); return this; }; /** * Hides the progress bar. * This is the *sort of* the same as setting the status to 100%, with the * difference being `done()` makes some placebo effect of some realistic motion. * * NProgress.done(); * * If `true` is passed, it will show the progress bar even if its hidden. * * NProgress.done(true); */ NProgress.done = function(force) { if (!force && !NProgress.status) return this; return NProgress.inc(0.3 + 0.5 * Math.random()).set(1); }; /** * Increments by a random amount. */ NProgress.inc = function(amount) { var n = NProgress.status; if (!n) { return NProgress.start(); } else { if (typeof amount !== 'number') { amount = (1 - n) * clamp(Math.random() * n, 0.1, 0.95); } n = clamp(n + amount, 0, 0.994); return NProgress.set(n); } }; NProgress.trickle = function() { return NProgress.inc(Math.random() * Settings.trickleRate); }; /** * Waits for all supplied jQuery promises and * increases the progress as the promises resolve. * * @param $promise jQUery Promise */ (function() { var initial = 0, current = 0; NProgress.promise = function($promise) { if (!$promise || $promise.state() === \"resolved\") { return this; } if (current === 0) { NProgress.start(); } initial++; current++; $promise.always(function() { current--; if (current === 0) { initial = 0; NProgress.done(); } else { NProgress.set((initial - current) / initial); } }); return this; }; })(); /** * (Internal) renders the progress bar markup based on the `template` * setting. */ NProgress.render = function(fromStart) { if (NProgress.isRendered()) return document.getElementById('nprogress'); addClass(document.documentElement, 'nprogress-busy'); var progress = document.createElement('div'); progress.id = 'nprogress'; progress.innerHTML = Settings.template; var bar = progress.querySelector(Settings.barSelector), perc = fromStart ? '-100' : toBarPerc(NProgress.status || 0), parent = document.querySelector(Settings.parent), spinner; css(bar, { transition: 'all 0 linear', transform: 'translate3d(' + perc + '%,0,0)' }); if (!Settings.showSpinner) { spinner = progress.querySelector(Settings.spinnerSelector); spinner && removeElement(spinner); } if (parent != document.body) { addClass(parent, 'nprogress-custom-parent'); } parent.appendChild(progress); return progress; }; /** * Removes the element. Opposite of render(). */ NProgress.remove = function() { removeClass(document.documentElement, 'nprogress-busy'); removeClass(document.querySelector(Settings.parent), 'nprogress-custom-parent'); var progress = document.getElementById('nprogress'); progress && removeElement(progress); }; /** * Checks if the progress bar is rendered. */ NProgress.isRendered = function() { return !!document.getElementById('nprogress'); }; /** * Determine which positioning CSS rule to use. */ NProgress.getPositioningCSS = function() { // Sniff on document.body.style var bodyStyle = document.body.style; // Sniff prefixes var vendorPrefix = ('WebkitTransform' in bodyStyle) ? 'Webkit' : ('MozTransform' in bodyStyle) ? 'Moz' : ('msTransform' in bodyStyle) ? 'ms' : ('OTransform' in bodyStyle) ? 'O' : ''; if (vendorPrefix + 'Perspective' in bodyStyle) { // Modern browsers with 3D support, e.g. Webkit, IE10 return 'translate3d'; } else if (vendorPrefix + 'Transform' in bodyStyle) { // Browsers without 3D support, e.g. IE9 return 'translate'; } else { // Browsers without translate() support, e.g. IE7-8 return 'margin'; } }; /** * Helpers */ function clamp(n, min, max) { if (n max) return max; return n; } /** * (Internal) converts a percentage (`0..1`) to a bar translateX * percentage (`-100%..0%`). */ function toBarPerc(n) { return (-1 + n) * 100; } /** * (Internal) returns the correct CSS for changing the bar's * position given an n percentage, and speed and ease from Settings */ function barPositionCSS(n, speed, ease) { var barCSS; if (Settings.positionUsing === 'translate3d') { barCSS = { transform: 'translate3d('+toBarPerc(n)+'%,0,0)' }; } else if (Settings.positionUsing === 'translate') { barCSS = { transform: 'translate('+toBarPerc(n)+'%,0)' }; } else { barCSS = { 'margin-left': toBarPerc(n)+'%' }; } barCSS.transition = 'all '+speed+'ms '+ease; return barCSS; } /** * (Internal) Queues a function to be executed. */ var queue = (function() { var pending = []; function next() { var fn = pending.shift(); if (fn) { fn(next); } } return function(fn) { pending.push(fn); if (pending.length == 1) next(); }; })(); /** * (Internal) Applies css properties to an element, similar to the jQuery * css method. * * While this helper does assist with vendor prefixed property names, it * does not perform any manipulation of values prior to setting styles. */ var css = (function() { var cssPrefixes = [ 'Webkit', 'O', 'Moz', 'ms' ], cssProps = {}; function camelCase(string) { return string.replace(/^-ms-/, 'ms-').replace(/-([\\da-z])/gi, function(match, letter) { return letter.toUpperCase(); }); } function getVendorProp(name) { var style = document.body.style; if (name in style) return name; var i = cssPrefixes.length, capName = name.charAt(0).toUpperCase() + name.slice(1), vendorName; while (i--) { vendorName = cssPrefixes[i] + capName; if (vendorName in style) return vendorName; } return name; } function getStyleProp(name) { name = camelCase(name); return cssProps[name] || (cssProps[name] = getVendorProp(name)); } function applyCss(element, prop, value) { prop = getStyleProp(prop); element.style[prop] = value; } return function(element, properties) { var args = arguments, prop, value; if (args.length == 2) { for (prop in properties) { value = properties[prop]; if (value !== undefined && properties.hasOwnProperty(prop)) applyCss(element, prop, value); } } else { applyCss(element, args[1], args[2]); } } })(); /** * (Internal) Determines if an element or space separated list of class names contains a class name. */ function hasClass(element, name) { var list = typeof element == 'string' ? element : classList(element); return list.indexOf(' ' + name + ' ') >= 0; } /** * (Internal) Adds a class to an element. */ function addClass(element, name) { var oldList = classList(element), newList = oldList + name; if (hasClass(oldList, name)) return; // Trim the opening space. element.className = newList.substring(1); } /** * (Internal) Removes a class from an element. */ function removeClass(element, name) { var oldList = classList(element), newList; if (!hasClass(element, name)) return; // Replace the class name. newList = oldList.replace(' ' + name + ' ', ' '); // Trim the opening and closing spaces. element.className = newList.substring(1, newList.length - 1); } /** * (Internal) Gets a space separated list of the class names on the element. * The list is wrapped with a single space on each end to facilitate finding * matches within the list. */ function classList(element) { return (' ' + (element.className || '') + ' ').replace(/\\s+/gi, ' '); } /** * (Internal) Removes an element from the DOM. */ function removeElement(element) { element && element.parentNode && element.parentNode.removeChild(element); } return NProgress; }); 列表 左对齐标题 右对齐标题 居中对齐标题 短文本 中等文本 稍微长一点的文本 稍微长一点的文本 短文本 中等文本 四级标题 五级标题 六级标题 Copyright @2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-08 13:39:10 "}}